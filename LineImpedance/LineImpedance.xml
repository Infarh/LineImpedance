<?xml version="1.0"?>
<doc>
    <assembly>
        <name>LineImpedance</name>
    </assembly>
    <members>
        <member name="T:LineImpedance.Calculator">
            <summary>Вычислитель</summary>
        </member>
        <member name="M:LineImpedance.Calculator.Kint(System.Double)">
            <summary>Комплементарный эллиптический интеграл</summary>
        </member>
        <member name="P:LineImpedance.Calculator.Eps">
            <summary>Диэлектрическая проницаемость диэлектрика</summary>
        </member>
        <member name="P:LineImpedance.Calculator.Impedance">
            <summary>Сопротивление линии</summary>
        </member>
        <member name="M:LineImpedance.Calculator.Calculate">
            <summary>Рассчитать</summary>
        </member>
        <member name="T:LineImpedance.Coaxial.CoaxialCalculator">
            <summary>Коаксиальная линия</summary>
        </member>
        <member name="P:LineImpedance.Coaxial.CoaxialCalculator.D1">
            <summary>Внутренний диаметр</summary>
        </member>
        <member name="P:LineImpedance.Coaxial.CoaxialCalculator.D2">
            <summary>Внешний диаметр</summary>
        </member>
        <member name="T:LineImpedance.Impedance">
            <summary>Сопротивление линии</summary>
        </member>
        <member name="M:LineImpedance.Impedance.Kint(System.Double)">
            <summary>Комплементарный эллиптический интеграл</summary>
        </member>
        <member name="M:LineImpedance.Impedance.Coaxial(System.Double,System.Double,System.Double)">
            <summary>Сопротивление коаксиальной линии</summary>
            <param name="d1">Диаметр центрального проводника</param>
            <param name="d2">Диаметр экрана</param>
            <param name="Eps">Диэлектрическая проницаемость подложки</param>
        </member>
        <member name="M:LineImpedance.Impedance.ThinMicroStrip(System.Double,System.Double,System.Double,System.Double)">
            <summary>Сопротивление симметричной полосковой линии с толстым полоском</summary>
            <param name="H">Высота подложки</param>
            <param name="W">Ширина полоска</param>
            <param name="T">Толщина полоска</param>
            <param name="Eps">Диэлектрическая проницаемость подложки</param>
        </member>
        <member name="M:LineImpedance.Impedance.StripLine(System.Double,System.Double,System.Double)">
            <summary>Сопротивление симметричной полосковой линии с тонким полоском</summary>
            <param name="H">Высота подложки</param>
            <param name="W">Ширина полоска</param>
            <param name="Eps">Диэлектрическая проницаемость подложки</param>
        </member>
        <member name="M:LineImpedance.Impedance.ThickStrip(System.Double,System.Double,System.Double,System.Double)">
            <summary>Сопротивление несимметричной полосковой линии</summary>
            <param name="H">Высота подложки</param>
            <param name="W">Ширина полоска</param>
            <param name="T">Толщина полоска</param>
            <param name="Eps">Диэлектрическая проницаемость подложки</param>
        </member>
        <member name="M:LineImpedance.Impedance.AsymmetricThickStrip(System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Сопротивление ассиметричной экранированной полосковой линии</summary>
            <param name="H1">Высота над полоском</param>
            <param name="H2">Высота под полоском</param>
            <param name="W">Ширина полоска</param>
            <param name="T">Толщина полоска</param>
            <param name="Eps">Диэлектрическая проницаемость подложки</param>
        </member>
        <member name="T:LineImpedance.MicroStrip.ThinMicroStripCalculator">
            <summary>Несимметричная полосковая линия</summary>
        </member>
        <member name="T:LineImpedance.StripLine.AsymmetricThickStripCalculator">
            <summary>Асимметричная экранированная полосковая линия</summary>
        </member>
        <member name="P:LineImpedance.StripLine.AsymmetricThickStripCalculator.Height1">
            <summary>Высота над полоском</summary>
        </member>
        <member name="P:LineImpedance.StripLine.AsymmetricThickStripCalculator.Height2">
            <summary>Высота под полоском</summary>
        </member>
        <member name="P:LineImpedance.StripLine.AsymmetricThickStripCalculator.Width">
            <summary>Ширина полоска</summary>
        </member>
        <member name="P:LineImpedance.StripLine.AsymmetricThickStripCalculator.Thickness">
            <summary>Толщина полоска</summary>
        </member>
        <member name="F:LineImpedance.StripLine.CoplanarCalculator.TestField">
            <summary>
            Тестовое поле
            </summary>
        </member>
        <member name="T:LineImpedance.StripLine.StripCalculator">
            <summary>Симметричная полосковая линия</summary>
        </member>
        <member name="T:System.Index">
            <summary>Represent a type can be used to index a collection either from the start or the end.</summary>
            <remarks>
            Index is used by the C# compiler to support the new index syntax
            <code>
            int[] someArray = new int[5] { 1, 2, 3, 4, 5 } ;
            int lastElement = someArray[^1]; // lastElement = 5
            </code>
            </remarks>
        </member>
        <member name="M:System.Index.#ctor(System.Int32,System.Boolean)">
            <summary>Construct an Index using a value and indicating if the index is from the start or from the end.</summary>
            <param name="value">The index value. it has to be zero or positive number.</param>
            <param name="FromEnd">Indicating if the index is from the start or from the end.</param>
            <remarks>
            If the Index constructed from the end, index value 1 means pointing at the last element and index value 0 means pointing at beyond last element.
            </remarks>
        </member>
        <member name="P:System.Index.Start">
            <summary>Create an Index pointing at first element.</summary>
        </member>
        <member name="P:System.Index.End">
            <summary>Create an Index pointing at beyond last element.</summary>
        </member>
        <member name="M:System.Index.FromStart(System.Int32)">
            <summary>Create an Index from the start at the position indicated by the value.</summary>
            <param name="value">The index value from the start.</param>
        </member>
        <member name="M:System.Index.FromEnd(System.Int32)">
            <summary>Create an Index from the end at the position indicated by the value.</summary>
            <param name="value">The index value from the end.</param>
        </member>
        <member name="P:System.Index.Value">
            <summary>Returns the index value.</summary>
        </member>
        <member name="P:System.Index.IsFromEnd">
            <summary>Indicates whether the index is from the start or the end.</summary>
        </member>
        <member name="M:System.Index.GetOffset(System.Int32)">
            <summary>Calculate the offset from the start using the giving collection length.</summary>
            <param name="length">The length of the collection that the Index will be used with. length has to be a positive value</param>
            <remarks>
            For performance reason, we don't validate the input length parameter and the returned offset value against negative values.
            we don't validate either the returned offset is greater than the input length.
            It is expected Index will be used with collections which always have non negative length/count. If the returned offset is negative and
            then used to index a collection will get out of range exception which will be same affect as the validation.
            </remarks>
        </member>
        <member name="M:System.Index.Equals(System.Object)">
            <summary>Indicates whether the current Index object is equal to another object of the same type.</summary>
            <param name="value">An object to compare with this object</param>
        </member>
        <member name="M:System.Index.Equals(System.Index)">
            <summary>Indicates whether the current Index object is equal to another Index object.</summary>
            <param name="other">An object to compare with this object</param>
        </member>
        <member name="M:System.Index.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
        </member>
        <member name="M:System.Index.op_Implicit(System.Int32)~System.Index">
            <summary>Converts integer number to an Index.</summary>
        </member>
        <member name="M:System.Index.ToString">
            <summary>Converts the value of the current Index object to its equivalent string representation.</summary>
        </member>
        <member name="T:System.Range">
            <summary>Represent a range has start and end indexes.</summary>
            <remarks>
            Range is used by the C# compiler to support the range syntax.
            <code>
            int[] someArray = new int[5] { 1, 2, 3, 4, 5 };
            int[] subArray1 = someArray[0..2]; // { 1, 2 }
            int[] subArray2 = someArray[1..^0]; // { 2, 3, 4, 5 }
            </code>
            </remarks>
        </member>
        <member name="P:System.Range.Start">
            <summary>Represent the inclusive start index of the Range.</summary>
        </member>
        <member name="P:System.Range.End">
            <summary>Represent the exclusive end index of the Range.</summary>
        </member>
        <member name="M:System.Range.#ctor(System.Index,System.Index)">
            <summary>Construct a Range object using the start and end indexes.</summary>
            <param name="start">Represent the inclusive start index of the range.</param>
            <param name="end">Represent the exclusive end index of the range.</param>
        </member>
        <member name="M:System.Range.Equals(System.Object)">
            <summary>Indicates whether the current Range object is equal to another object of the same type.</summary>
            <param name="value">An object to compare with this object</param>
        </member>
        <member name="M:System.Range.Equals(System.Range)">
            <summary>Indicates whether the current Range object is equal to another Range object.</summary>
            <param name="other">An object to compare with this object</param>
        </member>
        <member name="M:System.Range.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
        </member>
        <member name="M:System.Range.ToString">
            <summary>Converts the value of the current Range object to its equivalent string representation.</summary>
        </member>
        <member name="M:System.Range.StartAt(System.Index)">
            <summary>Create a Range object starting from start index to the end of the collection.</summary>
        </member>
        <member name="M:System.Range.EndAt(System.Index)">
            <summary>Create a Range object starting from first element in the collection to the end Index.</summary>
        </member>
        <member name="P:System.Range.All">
            <summary>Create a Range object starting from first element to the end.</summary>
        </member>
        <member name="M:System.Range.GetOffsetAndLength(System.Int32)">
            <summary>Calculate the start offset and length of range object using a collection length.</summary>
            <param name="length">The length of the collection that the range will be used with. length has to be a positive value.</param>
            <remarks>
            For performance reason, we don't validate the input length parameter against negative values.
            It is expected Range will be used with collections which always have non negative length/count.
            We validate the range is inside the length scope though.
            </remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray``1(``0[],System.Range)">
            <summary>
            Slices the specified array using the specified range.
            </summary>
        </member>
    </members>
</doc>
